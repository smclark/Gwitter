#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# This file is in the public domain
### END LICENSE

import sys
import os
import gtk

import gettext
from gettext import gettext as _
gettext.textdomain('gwitter')

# optional Launchpad integration
# this shouldn't crash if not found as it is simply used for bug reporting
try:
    import LaunchpadIntegration
    launchpad_available = True
except:
    launchpad_available = False

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'gwitter'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

from gwitter import (
    AboutGwitterDialog, PreferencesGwitterDialog)
from gwitter.helpers import get_builder

class GwitterWindow(gtk.Window):
    __gtype_name__ = "GwitterWindow"
    # To construct a new instance of this method, the following notable 
    # methods are called in this order:
    # __new__(cls)
    # __init__(self)
    # finish_initializing(self, builder)
    # __init__(self)
    #
    # For this reason, it's recommended you leave __init__ empty and put
    # your inialization code in finish_intializing
    
    def __new__(cls):
        """Special static method that's automatically called by Python when 
        constructing a new instance of this class.
        
        Returns a fully instantiated GwitterWindow object.
        """
        builder = get_builder('GwitterWindow')
        new_object = builder.get_object("gwitter_window")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        """Called while initializing this instance in __new__

        finish_initalizing should be called after parsing the UI definition
        and creating a GwitterWindow object with it in order to finish
        initializing the start of the new GwitterWindow instance.
        
        Put your initilization code in here and leave __init__ undefined.
        """
        # Get a reference to the builder and set up the signals.
        self.builder = builder
        self.builder.connect_signals(self)

        global launchpad_available
        if launchpad_available:
            # see https://wiki.ubuntu.com/UbuntuDevelopment/Internationalisation/Coding for more information
            # about LaunchpadIntegration
            helpmenu = self.builder.get_object('helpMenu')
            if helpmenu:
                LaunchpadIntegration.set_sourcepackagename('gwitter')
                LaunchpadIntegration.add_items(helpmenu, 0, False, True)
            else:
                launchpad_available = False

        # Uncomment the following code to read in preferences at start up.
        #dlg = PreferencesGwitterDialog.PreferencesGwitterDialog()
        #self.preferences = dlg.get_preferences()

        # Code for other initialization actions should be added here.
        max_chars = 147

    def about(self, widget, data=None):
        """Display the about box for gwitter."""
        about = AboutGwitterDialog.AboutGwitterDialog()
        response = about.run()
        about.destroy()

    def preferences(self, widget, data=None):
        """Display the preferences window for gwitter."""
        prefs = PreferencesGwitterDialog.PreferencesGwitterDialog()
        response = prefs.run()
        if response == gtk.RESPONSE_OK:
            # Make any updates based on changed preferences here.
            pass
        prefs.destroy()

    def quit(self, widget, data=None):
        """Signal handler for closing the GwitterWindow."""
        self.destroy()

    def on_destroy(self, widget, data=None):
        """Called when the GwitterWindow is closed."""
        # Clean up code for saving application state should be added here.
        gtk.main_quit()

        #All code for button interactions to go below this comment:

    def search_btn_clicked(self, widget, data=None):
        """Called whenever the search button is clicked. Method should be here to 
        either open a new window with the results in it or post results to the 
        main_feed_TV. Choices choices"""
        # Method to handle search here.
        search_text = self.get_text("txt_search")
        print search_text

    def tweet_btn_clicked(self,widget, data=None):
        """Called when the Tweet button is clicked. This should call a method that 
        will upload the text from the tweet_text box and post it to the current users
        twitter page using OAuth"""
        tweet_text = self.get_text("txt_tweet")        
        print tweet_text

    def btn_unfollow_clicked(self, widget, data=None):
        """Called when the user wants to unfollow another user and has pressed 
        the unfollow button in the account management area. Should probably present the
        user with a combo box style list with all the people they follow on it."""
        print "unfollow clicked"

    def btn_follow_clicked(self, widget, data=None):
        """Bring up a new window that the user can enter the details of the person
        they want to follow in. Either email address or username"""
        print "follow clicked"

    # Random Methods go here:

    def get_text(self, caller):
        """This method will determine which caller has asked to retrieve text 
        from one of the textboxes on the GUI. Depending on who called it will
        return the text from that text box."""
        
        if caller == "txt_search":
            search_text = self.builder.get_object("txt_search").get_text()
            return search_text
        elif caller == "txt_tweet":
            tweet_text = self.builder.get_object("txt_tweet").get_text()            
            return tweet_text

    def update_chars_left(self,widget,m,n ,data=None):
        """Calculate how many character the user has remaining to add to their Tweet 
        before it reaches the maximum limit imposed by Twitter: 147 characters"""
        global max_chars 
        if (max_chars - 1) == -1:
            print "Limit reached"
        else:
            max_chars = max_chars - 1
            self.update_status(max_chars)

    def update_status(self, chars):
        """this method is called everytime a user enters text into the Tweet text 
        box and alters the label on the status bar to show how many characters are left."""
        status_label = self.builder.get_object("status_lbl")
        status_label.set_text("%d characters left" % chars)

if __name__ == "__main__":
    # Support for command line options.
    import logging
    import optparse
    parser = optparse.OptionParser(version="%prog %ver")
    parser.add_option(
        "-v", "--verbose", action="store_true", dest="verbose",
        help=_("Show debug messages"))
    (options, args) = parser.parse_args()

    # Set the logging level to show debug messages.
    if options.verbose:
        logging.basicConfig(level=logging.DEBUG)
        logging.debug('logging enabled')

    # Run the application.
    max_chars = 147 
    #number of characters allowed in a single tweet. DONT KNOW WHERE ELSE TO PUT THIS HUNTLY!
    window = GwitterWindow()
    window.show()
    gtk.main()
